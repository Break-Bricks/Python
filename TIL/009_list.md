## 자료의 개수
  - ```py
    a = [1, 2, 3]
    len(a) # 3

## 수열 생성
  - ```py
    b = list(range(10))
    b # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    c = list(range(1, 10))
    c # [1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    d = list(range(1, 10, 3))
    d # [1, 4, 7]
    
## 값 바꾸기 (update)
  - 걍 대입해서 쓰면 됨
    - ```py
      d[0] = 100
      d # [100, 4, 7]
      
## 자료 추가
  - list 변수의 마지막에 자료를 더추가하려면 append method 사용
    - ```py
      e = list(range(4))
      e # [0, 1, 2, 3]
      e.append(4)
      e # [0, 1, 2, 3, 4]
      e.append(10)
      e # [0, 1, 2, 3, 10]
      
## 자료 삭제
  - list에서 자료를 하나 삭제하려면 `del` 명령을 사용
    - ```py
      f = list(range(5))
      f # [0, 1, 2, 3, 4]
      del f[0]
      f # [1, 2, 3, 4]
      del f[2]
      f # [1, 2, 4]
      
## slicing
  - list에서 특정 범위의 자료를 가져오고 싶을 때 사용
    - ```py
      g = list(range(20))
      g # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
      g[0:5] # 0번 index <= 1, 2, 3, 4 index < 5번 index -> [0, 1, 2, 3, 4]
      g[:5] # 시작 index가 0인 경우 콜론 앞 숫자 생략할 수 있음
      g[10:15] # [10, 11, 12, 13, 14]
      
## negative indexing
  - 음수 index를 사용하면 뒤에서부터 원소를 가리킴
  - 이때 가장 뒤의 원소는 0이 아니라 -1을 사용
    - ```py
      g[-1] # 19
      g[-5:-2] # -5번(뒤에서 5번째) index <= -4, -3 index < -2번 index [15, 16, 17]
      g[-3:] # 콜론 뒤에 숫자 생략하면 끝까지를 의미 -> [17, 18, 19]
      g[-3:-1] # [17, 18]
      
## 복수 할당 (multiple/unpack assignment)
  - list의 각 원소값을 여러 개의 변수에 나누어 넣고 싶을 때 쉼표를 써서 복수 할당 사용
    - ```py
      h = [1, 2, 3]
      h1, h2, h3 = h
      h1 # 1
      h2 # 2
      h3 # 3
  - 복수 할당을 할 때는 값이 들어갈 변수의 개수와 list의 길이가 같아야 함

## list와 반복문 사용
  - a1, a2 두 학생의 성적 변수가 list로 주어질 때 두 학생의 시험 성적의 합
    - ```py
      s = []
      a1 = [90, 85, 95, 80, 90, 100, 85, 75, 85, 80]
      a2 = [95, 90, 90, 90, 95, 100, 90, 80, 95, 90]
      for i in range(len(a1)):
          s.append(a1[i] + a2[i])
      s # [185, 175, 185, 170, 185, 200, 175, 155, 180, 170]
      
## list의 원소를 직접 반복문에서 사용
  - `range` 명령은 list를 만드는 명령
    - ```py
      list(range(5)) # [0, 1, 2, 3, 4]
  - 이 코드는
    - ```py
      for i in range(5):
  - 이 코드와 같음
    - ```py
      for i in [0, 1, 2, 3, 4]:
      
## enumerate 함수
  - 반복문에 정수 index가 필요할 때가 있음
  - 반복문에서 append method를 쓰면 계산 속도가 저하됨
  - 이 때 미리 저장공간을 만들어놓고 해당위치에 계산 결과 갱신하는 방식으로 ㄱㄱ (enumerate 사용)
    - ```py
      for i, e in enumerate(["a", "b", "c"]):
      print("i = %d, e = %s" % (i, e))
      # i = 0, e = a
      # i = 1, e = b
      # i = 2, e = c
      
## list의 list
  - ```py
    X = [[85,  90,  20,  50,  60,  25,  30,  75,  40,  55],
         [70, 100,  70,  70,  55,  75,  55,  60,  40,  45],
         [25,  65,  15,  25,  20,   5,  60,  70,  35,  10],
         [80,  45,  80,  40,  75,  35,  80,  55,  70,  90],
         [35,  50,  75,  25,  35,  70,  65,  50,  70,  10]]
    X[4][0] # 35
    X[0][1] # 90
    
## zip 함수
  - zip 함수는 두 개의 list를 합쳐서 각 list 원소의 쌍을 원소로 가지는 하나의 list를 만들어 줌
  - python3에서는 명시적으로 list 명령을 사용해야 list가 됨
    - ```py
      a1 = [90, 85, 95, 80, 90, 100, 85, 75, 85, 80]
      a2 = [95, 90, 90, 90, 95, 100, 90, 80, 95, 90]
      a12 = list(zip(a1, a2))
      a12
      # [(90, 95),
      #  (85, 90),
      #  (95, 90),
      #  (80, 90),
      #  (90, 95),
      #  (100, 100),
      #  (85, 90),
      #  (75, 80),
      #  (85, 95),
      #  (80, 90)]
    - 이 때 소괄호로 표시된 묶음을 tuple 이라고 함 (list와 사용법이 거의 동일)
    - ```py
      s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      a1 = [90, 85, 95, 80, 90, 100, 85, 75, 85, 80]
      a2 = [95, 90, 90, 90, 95, 100, 90, 80, 95, 90]
      for i, (a1i, a2i) in enumerate(zip(a1, a2)):
          s[i] = a1i + a2i
      s # [185, 175, 185, 170, 185, 200, 175, 155, 180, 170]
    - ```py
      s = []
      a1 = [90, 85, 95, 80, 90, 100, 85, 75, 85, 80]
      a2 = [95, 90, 90, 90, 95, 100, 90, 80, 95, 90]
      for a1i, a2i in zip(a1, a2):
          s.append(a1i + a2i)
      s # [185, 175, 185, 170, 185, 200, 175, 155, 180, 170]
